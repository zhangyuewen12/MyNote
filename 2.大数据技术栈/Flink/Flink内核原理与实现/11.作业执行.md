## 一、概要	

​	Flink 作业真正执行起来之后，会在物理上构成Task相互连接的DAG，在执行过程中上游Task结果写入结果分区，结果分区又分为结果子分区，下游的Task通过InputGate与上游建立数据传输通道，InputGate中的InputChannel对应于结果子分区，将数据交给Task执行。

​	Task执行的时候，根据数据的不同类型（StreamRecord，Watermark,LatencyMarker）进行不同的处理逻辑，处理完后再交给下游的Task。



![image-20220818191054028](/Users/zyw/Library/Application Support/typora-user-images/image-20220818191054028.png)



### 二、输入处理器(interface StreamInputProcessor)

> ```
> /**
>  * Interface for processing records by {@link org.apache.flink.streaming.runtime.tasks.StreamTask}.
>  */
> @Internal
> public interface StreamInputProcessor extends AvailabilityProvider, Closeable {
>     /**
>      * In case of two and more input processors this method must call {@link
>      * InputSelectable#nextSelection()} to choose which input to consume from next.
>      *
>      * @return input status to estimate whether more records can be processed immediately or not. If
>      *     there are no more records available at the moment and the caller should check finished
>      *     state and/or {@link #getAvailableFuture()}.
>      */
>     InputStatus processInput() throws Exception;
> 
>     CompletableFuture<Void> prepareSnapshot(
>             ChannelStateWriter channelStateWriter, long checkpointId) throws CheckpointException;
> }
> ```

输入处理器在Flink中叫做StreamInputProcessor，是对StreamTask中读取数据行为的抽象，其实现包括数据的读取、处理、输出给下游的过程。

对应于单流输入和双流输入，多流输入，StreamInputProcessor也提供了三种实现。

<img src="/Users/zyw/Library/Application Support/typora-user-images/image-20220818191801041.png" alt="image-20220818191801041" style="zoom:50%;" />

其中通过输入处理器和输出处理器来完成。

> ```
>     private StreamTaskInput<IN> input;
>     private final DataOutput<IN> output;
> ```



### 

### 三、结果分区（ResultPartition）

>
>
>```
>/**
> * A result partition for data produced by a single task.
> *
> * <p>This class is the runtime part of a logical {@link IntermediateResultPartition}. Essentially,
> * a result partition is a collection of {@link Buffer} instances. The buffers are organized in one
> * or more {@link ResultSubpartition} instances or in a joint structure which further partition the
> * data depending on the number of consuming tasks and the data {@link DistributionPattern}.
> *
> * <p>Tasks, which consume a result partition have to request one of its subpartitions. The request
> * happens either remotely (see {@link RemoteInputChannel}) or locally (see {@link
> * LocalInputChannel})
> *
> * <h2>Life-cycle</h2>
> *
> * <p>The life-cycle of each result partition has three (possibly overlapping) phases:
> *
> * <ol>
> *   <li><strong>Produce</strong>:
> *   <li><strong>Consume</strong>:
> *   <li><strong>Release</strong>:
> * </ol>
> *
> * <h2>Buffer management</h2>
> *
> * <h2>State management</h2>
> */
>public abstract class ResultPartition implements ResultPartitionWriter {
>}
>
>结果分区用来表示单个Task产生的结果。
>ResultPartition是运行时实体。与IntermediateResultPartition对应。
>1. 本质上一个结果分区是一个Buffer的结合。
>2. 结果分区是由结果子分区（ResultSubPartition）组成，结果子分区的数量取决于下游消费Task的数量。
>例如，上游Task对接下游4个Task，ResultPartition生产4个ResultSubPartition。
>3. Task消费结果分区，本质上是去消费ResultSubPartion。
>```



### 四、输入网关（InputGate）

输入网关在Flink叫做InputGate，是Task的输入数据的封装，和JobGraph中的JobEdge一一对应，对应于上游的ResultP

> ```
> /**
>  * An input gate consumes one or more partitions of a single produced intermediate result.
>  *
>  * <p>Each intermediate result is partitioned over its producing parallel subtasks; each of these
>  * partitions is furthermore partitioned into one or more subpartitions.
>  *
>  * <p>As an example, consider a map-reduce program, where the map operator produces data and the
>  * reduce operator consumes the produced data.
>  *
>  * <pre>{@code
>  * +-----+              +---------------------+              +--------+
>  * | Map | = produce => | Intermediate Result | <= consume = | Reduce |
>  * +-----+              +---------------------+              +--------+
>  * }</pre>
>  *
>  * <p>When deploying such a program in parallel, the intermediate result will be partitioned over
>  * its producing parallel subtasks; each of these partitions is furthermore partitioned into one or
>  * more subpartitions.
>  *
>  * <pre>{@code
>  *                            Intermediate result
>  *               +-----------------------------------------+
>  *               |                      +----------------+ |              +-----------------------+
>  * +-------+     | +-------------+  +=> | Subpartition 1 | | <=======+=== | Input Gate | Reduce 1 |
>  * | Map 1 | ==> | | Partition 1 | =|   +----------------+ |         |    +-----------------------+
>  * +-------+     | +-------------+  +=> | Subpartition 2 | | <==+    |
>  *               |                      +----------------+ |    |    | Subpartition request
>  *               |                                         |    |    |
>  *               |                      +----------------+ |    |    |
>  * +-------+     | +-------------+  +=> | Subpartition 1 | | <==+====+
>  * | Map 2 | ==> | | Partition 2 | =|   +----------------+ |    |         +-----------------------+
>  * +-------+     | +-------------+  +=> | Subpartition 2 | | <==+======== | Input Gate | Reduce 2 |
>  *               |                      +----------------+ |              +-----------------------+
>  *               +-----------------------------------------+
>  * }</pre>
>  *
>  * <p>In the above example, two map subtasks produce the intermediate result in parallel, resulting
>  * in two partitions (Partition 1 and 2). Each of these partitions is further partitioned into two
>  * subpartitions -- one for each parallel reduce subtask. As shown in the Figure, each reduce task
>  * will have an input gate attached to it. This will provide its input, which will consist of one
>  * subpartition from each partition of the intermediate result.
>  */
> public abstract class InputGate implements PullingAsyncDataInput<BufferOrEvent>, AutoCloseable, ChannelStateHolder{
> 
> }
> 
> 1. 作业的并发度为2，有两个map子任务分别产生数据，生成两个ResultPartition。
> 2. 每个ResultPartition又被分成两个ResultSubPartition（结果子分区的数量取决于下游Reduce任务的子任务个数）。
> 3. 每个Reduce的子任务都有一个InputGate，负责从上游的所有ResultPartition中获取该子任务所需要的ResultSubPartition。
> 4. 每个InputChannel会包含一个以上的InputChannel和ExecutionEdge一一对应，也和结果子分区（ResultSubPartition）一对一相连，即一个InputChannel接收一个ResultSubPartition。
> ```



### 五、Task执行

启动Task进入执行状态，开始读取数据，当有可消费的数据时，则持续读取数据，如

```
```

