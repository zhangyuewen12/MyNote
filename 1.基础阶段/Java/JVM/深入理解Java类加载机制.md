**Java类加载机制**

首先我们需要思考一件事，我们编写的Java代码，是如何在各种各样的操作系统上运行起来的。

![image-20220521090756373](/Users/zyw/Library/Application Support/typora-user-images/image-20220521090756373.png)

**Java文件通过Javac编译成class文件，这种中间码被称为字节码。然后由JVM加载字节码。这个过程就称为类加载**。



**类的生命周期**



在详细讲解之前，我们明确一下类加载流程的目的。站在高处去看，就是把一份被javac编译过的文件通过加载，生成某种形式的class文件的数据结构送进内存。程序可以调用这个数据结构来构造出Java对象。这个过程是在运行时进行的，也是Java动态拓展性的根基。



![image-20220521090841825](/Users/zyw/Library/Application Support/typora-user-images/image-20220521090841825.png)

上面这张图表现了类的整个生命周期。而类加载呢，只包含了加载、链接和初始化三个阶段。加载只是类加载的第一个环节，两者要注意区分。解析部分是灵活的，它可以在初始化环节之前或者之后进行，实现后期绑定。类加载的其他环节的顺序是不可改变的。

**加载**

加载是一个读取class文件，将其转化为某种静态数据结构而存储在方法区内，并在堆中生成一个便于用户调用的Java对象的过程。
这里值得注意的是，这个Java文件不一定是本地文件，泛指各种来源的二进制流，比如网络、数据库或者比如动态代理技术这样的即时生成的class文件。

**验证**

验证的步骤很多，上面的图画得不完全准确。对文件格式的校验其实是发生在加载阶段的。通过才能顺利加载。顺利加载并不代表JVM完全认可了这个类，还要进行语法和语义上的分析，保证这个类不会危害JVM，这是对元数据和字节码上的验证。在解析阶段，还会进行符号引用的验证。随着JVM版本的升高，验证过程也在被不断丰富。

**准备**



准备就是为静态变量赋初始值，注意这里的初始值是JVM默认初始值，是固定的，不是咱们写代码时的那个初始值。这里有个比较容易混淆的概念。



Java内存规范定义了方法区这种抽象概念。主流的JVM实现如HotSpot在JDK8之前使用永久代这种在堆中开辟专门空间的实现方式，JDK8之后使用元空间这种直接内存取代。



HotSpot的实现：类的元信息、常量池、静态变量等都存在在JDK8之前都存在在永久代这种方法区的具体实现中。JDK8之后，常量池、静态变量被从方法区移除，转移到了堆中。元信息这些依然保留在方法区，具体的存储方式改成了元空间。

**解析**



解析是将符号引用替换为直接引用。



**静态解析**



符号引用就是假如类A引用了类B，加载阶段是静态解析，这时候B还没有被放到JVM内存中，这时候A引用的只是代表B的符号，这是符号引用。



直接引用就是类A在解析阶段发现自己引用了B，如果这个时候B还没被加载。就是直接触发B的类加载，之后B的符号引用会被替换成实际地址。这被称为直接引用。



**动态解析**



本文类的生命周期部分引出了后期绑定这个概念。后期绑定其实就是动态解析。如果代码使用了多态。B是一个抽象类或者接口，A就不能知道究竟要用哪个来替换，只能等到实际发生调动时在进行实际地址的替换。这就是为什么有的解析发生在初始化之后。

**总结**



类加载的过程今天就讲这些。咱们来回顾一下类加载的五个阶段

![image-20220521090955283](/Users/zyw/Library/Application Support/typora-user-images/image-20220521090955283.png)

